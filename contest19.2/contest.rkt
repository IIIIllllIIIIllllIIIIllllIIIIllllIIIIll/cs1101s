;
; CS1101S --- Programming Methodology
;
; Death to the Cube

(require "engine-contest.rkt")

(require racket)
(require racket/sandbox)

(require data/queue)

(define sub-dir "submissions")
(define bracket-dir "brackets")
(define logs-dir "logs")
(define logs-pref "log")
(define logs-ext ".txt")
(define extension ".rkt")
(define bracket "bracket")
(define players "players")
(define results "results")
(define prot-pattern (regexp-quote (string-append players "0" extension)))
(define subpref "showdown-")
(define digit "[0-9a-f]")
(define die-size 100)

(define started-time #f)

(define (make&install-player name birthplace)
  (let ((player (make-player name birthplace)))
    (ask (register player) 'install)
    player))

(define-syntax if
  (syntax-rules ()
    ((if c y)
     (cond (c y)))
    ((if c y n)
     (cond (c y) (else n)))))

(define (find-lists)
  (let ((pattern (string-append (regexp-quote players) "(" digit "+)" (regexp-quote extension))))
    (filter-map
     (λ (path)
       (let ((str (path->string path)))
         (regexp-match pattern path)))
     (directory-list bracket-dir))))

(define (find-brackets lists)
  (let ((dir-list (directory-list bracket-dir)))
    (map
     (λ (lst)
       (append lst
               (filter-map
                (λ (path)
                  (let ((str (path->string path))
                        (pattern (string-append (regexp-quote bracket)
                                                (regexp-quote (cadr lst))
                                                "(" digit "+)"
                                                (regexp-quote extension))))
                    (regexp-match pattern path)))
                dir-list)))
     lists)))
(define (next-list brackets)
  (findf
   (compose null? cddr)
   brackets))
(define (gen-brackets file min-size max-size)
  (define (make-brackets p size)
    (let iter ((random-sort (sort p
                                  (λ (a b)
                                    (<= (random die-size)
                                        (random die-size))))))
      (if (null? random-sort)
          '()
          (call-with-values
           (λ ()
             (with-handlers ((exn:fail? (λ (exn) (values random-sort '()))))
               (split-at random-sort size)))
           (λ (a b)
             (cons a (iter b)))))))
  (let ((ns (make-namespace)))
    (eval `(load ,file) ns)
    (let* ((len (eval '(length players) ns))
           (best-size (argmax (λ (div)
                                (let ((rem (remainder len div)))
                                  (if (zero? rem) div rem)))
                              (build-list (- max-size min-size -1) (λ (x) (+ x min-size))))))
      (make-brackets (eval 'players ns) best-size))))

(define (write-next-bracket brackets min-size max-size)
  (cond ((next-list brackets)
         => (λ (list)
              (let iter ((b (gen-brackets (string-append bracket-dir "/" (car list)) min-size max-size))
                         (c 0))
                (unless (null? b)
                  (let ((file (string-append bracket-dir "/" bracket (cadr list) (number->string c 16) extension)))
                    (display-to-file "(define players\n  '(" file #:mode 'text #:exists 'replace)
                    (display-lines-to-file (car b) file #:separator "\n    " #:mode 'text #:exists 'append)
                    (display-to-file "))" file #:mode 'text #:exists 'append))
                  (iter (cdr b) (+ c 1))))
              list))
        (else #f)))
(define (clear-bracket-dir type prefix)
  (let ((pattern (string-append (regexp-quote type) (regexp-quote prefix) digit "+" (regexp-quote extension))))
    (for-each (λ (path)
                (when (and (regexp-match pattern path)
                           (not (regexp-match prot-pattern path)))
                  (delete-file (string-append bracket-dir "/" (path->string path)))))
              (directory-list bracket-dir))))
(define (clear-results prefix)
  (clear-bracket-dir results prefix))
(define (clear-brackets prefix)
  (clear-results prefix)
  (clear-bracket-dir bracket prefix)
  (clear-bracket-dir players prefix))
(define (clear-all-brackets)
  (clear-brackets ""))

(define (find-results bracket)
  (let ((dir-list (directory-list bracket-dir))
        (prefix (cadr bracket)))
    (list* (car bracket)
           prefix
           (map (λ (lst)
                  (append lst
                          (cond ((findf (λ (path)
                                          (string=? (string-append results prefix (cadr lst) extension)
                                                    (path->string path)))
                                        dir-list)
                                 => list)
                                (else '()))))
                (cddr bracket)))))

(define (next-unplayed bracket)
  (ormap (λ (result)
           (if (null? (cddr result))
               (string-append (cadr bracket)
                              (cadr result))
               #f))
         (cddr bracket)))
(define (last-round bracket)
  (let ((round (next-unplayed bracket)))
    (if (and round
             (null? (cdddr bracket)))
        round
        #f)))

(define (record-results idx result-lst winners)
  (let ((file (string-append bracket-dir "/" results idx extension)))
    (display-to-file "(define results\n  '(" file #:mode 'text #:exists 'replace)
    (display-lines-to-file result-lst file #:separator "\n    " #:mode 'text #:exists 'append)
    (display-to-file "))" file #:mode 'text #:exists 'append)
    
    (display-to-file "\n\n(define winners\n  '(" file #:mode 'text #:exists 'append)
    (display-lines-to-file winners file #:separator "\n    " #:mode 'text #:exists 'append)
    (display-to-file "))" file #:mode 'text #:exists 'append))
  (displayln winners))

(define (combine-list results lst-num)
  (let ((names (map (λ (bracket)
                      (cond ((and (not (null? (cddr bracket)))
                                  (cddr bracket))
                             => car)
                            (else #f)))
                    (cddr results))))
    (if (andmap identity names)
        (let ((ns (make-namespace))
              (file (string-append bracket-dir "/" players (number->string lst-num 16) extension)))
          (display-to-file "(define players\n  '(" file #:mode 'text #:exists 'replace)
          (for-each (λ (name)
                      (eval `(load ,(string-append bracket-dir "/" (path->string name))) ns)
                      (display-lines-to-file (eval 'winners ns) file #:separator "\n    " #:mode 'text #:exists 'append))
                    names)
          (display-to-file "))" file #:mode 'text #:exists 'append))
        #f)))

(define (play-round idx [min-winners 2])
  (let ((file (string-append bracket-dir "/" bracket idx extension))
        (b-ns (make-namespace))
        (gamestats-default '(0 0 0 0))
        (def-out (current-output-port)))
    (eval `(load ,file) b-ns)
    (let ((vars '(make-player shortname sabercolour lasercolour spellcolour bombcolour))
          (player-lst (eval 'players b-ns)))
      (display "Next up: Round ")
      (displayln idx)
      (displayln (map car player-lst))
      (current-output-port (open-output-file-wrapper (string-append logs-dir "/" logs-pref idx logs-ext)))
      (init-places)
      (let iter ((p player-lst))
        (unless (null? p)
          (let ((pname (caar p))
                (stats (list (cadar p))) ; level
                (gamestats (if (null? (cddar p)) '(0 0 0 0)
                               (cddar p)))) ; kills, evacs, points, wins
            (let undef ((v vars))
              (unless (null? v)
                (with-handlers ((exn:fail:contract:variable? void))
                  (namespace-undefine-variable! (car v)))
                (undef (cdr v))))
            (load (string-append sub-dir "/" subpref (symbol->string pname) extension))
            (let ((player (make-player pname JFDI-ship)))
              (set-obj-stats! (register player) stats)
              (with-handlers ((exn:fail:contract:variable? void))
                (set-obj-name! player
                               (if (string? shortname)
                                   shortname
                                   (symbol->string shortname))))
              (ask player 'install)
              (let ((wpns
                     (map (λ (wpn colour)
                            (when colour
                              (ask wpn 'set-atk-colour colour))
                            wpn)
                          (map (λ (constructor)
                                 (apply constructor JFDI-ship stats))
                               (list make&install-lightsaber
                                     make&install-lightsaber
                                     make&install-laser
                                     make&install-lightning
                                     make&install-lightning
                                     make&install-gen-bomb))
                          (map (λ (c)
                                 (with-handlers ((exn:fail:contract:variable? (const #f)))
                                   (send the-color-database find-color (eval c))))
                               `(sabercolour sabercolour lasercolour spellcolour spellcolour bombcolour)))))
                (apply ask player 'take wpns)
                (ask player 'modify-max-health (floor (* 3/2 (car stats))))
                (ask player 'modify-regeneration (floor (/ (car stats) 15)))
                (for-each (λ (a b) (ask player 'new-attack a b))
                          '(saber saber2 laser lightning lightning2 bomb)
                          wpns)
                (hash-update! score-table player identity gamestats-default)
                (hash-update! full-score-table player identity gamestats)))
            (iter (cdr p))))))
    (add-end-game-cond
     (λ ()
       (not (findf (λ(item)
                     (is-a item 'generator?))
                   (ask gen-room 'things))))
     (λ ()
       (end-mission)
       (close-output-port (current-output-port))
       (current-output-port def-out)
       (displayln "")
       (apply record-results idx (find-winners min-winners))
       (popup-message "Success!" "Congratulations! The generator has been destroyed!")))
    (add-end-game-cond
     (λ ()
       (and started-time
            (> (- (current-milliseconds) started-time) run-limit)))
     (λ ()
       (end-mission)
       (close-output-port (current-output-port))
       (current-output-port def-out)
       (displayln "")
       (apply record-results idx (find-winners min-winners))
       (popup-message "Fall back!" "This attack run has taken too long! We'd best retreat for now...")))
    (start-mission)
    (set! started-time (current-milliseconds))))

(define (next-round [min-size 4] [max-size 6])
  (let* ((lists (find-lists))
         (brackets (find-brackets lists))
         (all-results (map find-results brackets)))
    (cond ((ormap last-round all-results)
           => (λ (idx)
                (play-round idx 1)))
          ((ormap next-unplayed all-results)
           => play-round)
          ((write-next-bracket brackets min-size max-size)
           (next-round))
          ((combine-list (last all-results) (length lists))
           (next-round))
          (else #f))))

(next-round)